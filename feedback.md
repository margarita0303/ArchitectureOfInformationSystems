## Feedback

### Архитектура

Архитектура крайне похожа на архитектуру выбранную нашей командой. 
По этой причине основной вектор добавления новых команд был очевиден.

Есть небольшие отличия в наборе базовых классов и делигирования функций.
Так например у ребят есть отдельный класс отвечающий за разбиение входа на токены, и отдельный парсер.
У нас же в свою очередь эти две задачи делает сразу парсер. 
Но фактически эту область не нужно было затрагивать в процессе разработки, поэтому все окей.

Из недостатков хочется выделить хранение возможных команд.
В процессе добавления команд, я открыл класс factory который должен порождать нужную команду.
В нем я увидел что мне необходимо добавить некий enum CommandType.LS, чтобы по ниму делать свитч.
Я добавляю CommandType.LS, запускаю программу все работает. На добавлении CD у меня начали появляются вопросы,
но breakpoint почему-то не срабатывал ни в CDCommand ни в LSCommand, которая работала. 
Оказалось что команда ls не работает, она распознается как unknown и делает запрос в обычный bash.
А чтобы заработала моя команда, мне нужно добавить упоминаниие про LS и CD в третье место, в парсер.
Таким образом, чтобы программа узнала о существовании новой команды, необходимо указать о ней в трех местах, что не является очевидным.

### Наследование от Interface

Ребята зачем-то создают интерфейс абсолютно для каждого класса. Сначала я подумал, что это особенность Kotlin, но оказалось что это их архитектура.
С моей точки зрения преимущества данной архитектуру заклчючается в том, что мы можем заранее задать себе список методов, которые нам пригодятся, и стараться обходиться только ими.
Из минусов, это необходимость писать ВЕСЬ код два раза. Также размножаем наши файлы в проекте в два раза. 
В случае команды применение интерфейса очевидно, и является необходимостью. Мы имеем множество реализаций уже прямо сейчас.
Возможно есть какие-то классы, которые МОГУТ получить другую реализацию в будущем, например UserInterface.
Но также есть классы которые с 90% вероятностью не получат второй вариант реализации и интерфейс для них лежит просто как лишний мусор.
Это субъективно, но например мне кажется что Tokenizer и Parser могут быть теми классами, которые пишут один раз и больше никогда не трогают.


### Command Unknown

При реализации cd необходимо сделать, чтобы незнакомые команды также учитывали текущую дерикторию. 
У ребят считалось, что все аргументы просто собираются в одну строку и отправляются на вход в cmd. 
Таким образом пришлось добавлять костыль, чтобы реализовать текущую дирикторию. 

### Тесты

Очень маленькие тесты. По одному тесту на команду - слишком мало. Не получается полностью понять, как должна работать команда.
Опять же отсылаясь на UnknownCommand нет примера запуска внешнего скрипта, например python. Непонятно должна ли эта команда вообще работать с файлами.
